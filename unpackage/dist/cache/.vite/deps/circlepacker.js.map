{
  "version": 3,
  "sources": ["../../../../../node_modules/circlepacker/dist/circlepacker.node.mjs"],
  "sourcesContent": ["/*! circlepacker v2.1.0 | MIT (c) 2024 Georg Fischer <hi@snorpey.com> | https://github.com/snorpey/circlepacker#readme */\n/**\n * @typedef {Object} CirclePackerParams\n * @prop {OnMoveCallback}[onMove] - The onMove callback. Your render function goes here.\n * @prop {BoundsData} [bounds] - The boundaries of the area\n * @prop {PackedCircleData[]} [circles] - The circles\n * @prop {VectorData} [target] - The attraction target\n * @prop {boolean} [animationLoop=false] - Update the circle positions in a continuous animation loop?\n * @prop {number} [centeringPasses=1] - The number of centering passes\n * @prop {number} [collisionPasses=3] - The number of collistion passes\n * @prop {number} [correctionPasses=3] - The number of overlap correction passes\n * @prop {boolean} [calculateOverlap=false] - Calculate overlap for circles\n * @prop {boolean} [noWorker=false] - Set to true to skip using the Web Worker\n * @prop {boolean} [destroyAfterOneMove=false] - If set to true, worker is terminated after first onMove callback.\n *\n * @callback OnMoveStartCallback\n * @param {CirclePackerMovementResult} updatedCircles - An object containing all circle data\n * @returns {void}\n *\n * @callback OnMoveCallback\n * @param {CirclePackerMovementResult} updatedCircles - An object containing all circle data\n * @param {VectorData} [target] - The attraction target position\n * @param {CirclePackerOverlappingCircles} [overlappingCircles] - An object containing information about overlapping circles\n * @returns {void}\n *\n * @callback OnMoveEndCallback\n * @param {CirclePackerMovementResult} updatedCircles - An object containing all circle data\n * @returns {void}\n *\n * @typedef {Object} VectorData\n * @prop {number} x - The X component of the vector\n * @prop {number} y - The Y component of the vector\n *\n * @typedef {number | string} CircleID\n *\n * @typedef {Object} PackedCircleData\n * @prop {CircleID} id - The ID of the circle\n * @prop {number} [x] - The X position of the circle\n * @prop {number} [y] - The Y position of the circle\n * @prop {VectorData} [position] - The position object of the circle\n * @prop {number} radius - The circle radius\n * @prop {boolean} [isPinned=false] - Is circle pinnd\n * @prop {boolean} [isPulledToTarget=false] - Is circle pulled towards the target\n *\n * @typedef {Object} PackedCircle\n * @prop {CircleID} id - The ID of the circle\n * @prop {VectorData} position - The position of the circle\n * @prop {VectorData} [targetPosition] - The target position of the circle\n * @prop {VectorData} previousPosition - The previous position of the circle\n * @prop {number} radius - The circle radius\n * @prop {boolean} [isPinned=false] - Is circle pinnd\n * @prop {boolean} [isPulledToTarget=false] - Is circle pulled towards the target\n *\n * @typedef {PackedCircleData | PackedCircle | CircleID} CircleRef\n *\n * @typedef {Object} PackedCircleMovementData\n * @prop {CircleID} id - The ID of the circle\n * @prop {VectorData} position - The current position of the circle\n * @prop {VectorData} previousPosition - The previous position of the circle\n * @prop {number} radius - The radius of the circle\n * @prop {VectorData} delta - The movement vector of the circle\n * @prop {boolean} isPulledToTarget - Is the circle pulled towards the target\n * @prop {boolean} isPinned - Is the circle pinned\n *\n * @typedef {{[key: CircleID]: PackedCircleMovementData}} CirclePackerMovementResult\n *\n * @typedef OverlapData\n * @prop {CircleID} overlappingCircleId - The ID of the overlapping circle\n * @prop {number} overlapDistance - The overlap distance (measured along the line between two circle centers)\n *\n * @typedef {{[key: CircleID]: OverlapData[]}} CirclePackerOverlappingCircles\n *\n * @typedef {Object} CircleData\n * @prop {CircleID} id - The ID of the circle\n * @prop {VectorData} position - The position of the circle\n * @prop {number} radius - The circle radius\n * @prop {boolean} [isPinned=false] - Is the circle pinned? (pinned circles don't move)\n *\n * @typedef {CircleData | CircleID} CircleRef\n *\n * @typedef {Object} WorkerMessage\n * @prop {number} messageId - Unique ID of the message\n * @prop {WorkerAction} action - Action that the worker should take\n *\n * @typedef {Object} BoundsPoints\n * @prop {VectorData} point1 - The first corner\n * @prop {VectorData} point2 - The second corner\n *\n * @typedef {Object} BoundsDimensions\n * @prop {number} width - The bounds width\n * @prop {number} height - The bounds height\n * @prop {number} [x=0] - The bounds x position\n * @prop {number} [y=0] - The bounds y position\n *\n * @typedef {Object} BoundsRect\n * @prop {number} left - The bounds x position\n * @prop {number} top - The bounds y position\n * @prop {number} right - The bounds x2 position\n * @prop {number} bottom - The bounds y2 position\n *\n * @typedef {Object} BoundsPositions\n * @prop {number} x1 - The x value of the first corner\n * @prop {number} y1 - The y value of the first corner\n * @prop {number} x2 - The x value of the second corner\n * @prop {number} y2 - The y value of the second corner\n *\n * @typedef {BoundsDimensions | BoundsPoints | BoundsRect | BoundsPositions} BoundsData - Data needed to construct a Bounds instance\n *\n * @typedef {Object} SetBoundsAction\n * @prop {'SET_BOUNDS'} type\n * @prop {BoundsData} bounds - The new bounds object\n *\n * @typedef {Object} CenteringPassesAction\n * @prop {'SET_CENTERING_PASSES'} type\n * @prop {number} numberOfCenteringPasses - The new number of centering passes\n *\n * @typedef {Object} CollisionPassesAction\n * @prop {'SET_COLLISION_PASSES'} type\n * @prop {number} numberOfCollisionPasses - The new number of collision passes\n *\n * @typedef {Object} CorrectionPassesAction\n * @prop {'SET_CORRECTION_PASSES'} type\n * @prop {number} numberOfCorrectionPasses - The new number of correction passes\n *\n * @typedef {Object} CalculateOverlapAction\n * @prop {'SET_CALCULATE_OVERLAP'} type\n * @prop {boolean} calculateOverlap - The new calculateOverlap value\n *\n * @typedef {Object} DampingAction\n * @prop {'SET_DAMPING'} type\n * @prop {number} damping - The new damping value\n *\n * @typedef {Object} UpdateAction\n * @prop {'UPDATE'} type\n *\n * @typedef {Object} TargetPullAction\n * @prop {'SET_TARGET_PULL'} type\n * @prop {boolean} targetPull - The new target pull value\n *\n * @typedef {Object} AddCirclesAction\n * @prop {'ADD_CIRCLES'} type\n * @prop {PackedCircleData[]} circles - The new circles to add\n *\n * @typedef {Object} RemoveCircleAction\n * @prop {'REMOVE_CIRCLE'} type\n * @prop {CircleID} id - The ID of the circle to remove\n *\n * @typedef {Object} DragStartAction\n * @prop {'DRAG_START'} type\n * @prop {CircleID} id - The ID of the circle\n *\n * @typedef {Object} DragEndAction\n * @prop {'DRAG_END'} type\n * @prop {CircleID} id - The ID of the circle\n *\n * @typedef {Object} DragMoveAction\n * @prop {'DRAG_MOVE'} type\n * @prop {CircleID} id - The ID of the circle\n * @prop {VectorData} position - The new position of the circle\n *\n * @typedef {Object} CircleRadiusAction\n * @prop {'SET_CIRCLE_RADIUS'} type\n * @prop {CircleID} id - The ID of the circle\n * @prop {number} radius - The new radius of the circle\n *\n * @typedef {Object} CircleTargetPullAction\n * @prop {'SET_CIRCLE_TARGET_PULL'} type\n * @prop {CircleID} id - The ID of the circle\n * @prop {boolean} targetPull - The new targetPull value\n *\n * @typedef {Object} PinCircleAction\n * @prop {'PIN_CIRCLE'} type\n * @prop {CircleID} id - The ID of the circle\n *\n * @typedef {Object} UnpinCircleAction\n * @prop {'UNPIN_CIRCLE'} type\n * @prop {CircleID} id - The ID of the circle\n *\n * @typedef {Object} SetTargetAction\n * @prop {'SET_TARGET'} type\n * @prop {VectorData} target - The new position of the attraction target\n *\n * @typedef { SetBoundsAction | CenteringPassesAction | CollisionPassesAction | CorrectionPassesAction | DampingAction | UpdateAction | TargetPullAction | AddCirclesAction | RemoveCircleAction | DragStartAction | DragMoveAction | DragEndAction | CircleRadiusAction | CircleTargetPullAction | PinCircleAction | UnpinCircleAction | SetTargetAction } WorkerAction\n *\n * @typedef {Object} MoveResponse\n * @prop {'MOVED'} type\n * @prop {CirclePackerMovementResult} updatedCircles - An object containing all circle data\n * @prop {VectorData} [target] - The attraction target position\n * @prop {CirclePackerOverlappingCircles} [overlappingCircles] - An object containing information about overlapping circles\n *\n * @typedef {Object} MoveStartResponse\n * @prop {'MOVE_START'} type\n *\n * @typedef {Object} MoveEndResponse\n * @prop {'MOVE_END'} type\n * @prop {CirclePackerMovementResult} updatedCircles - An object containing all circle data\n *\n * @typedef { MoveResponse | MoveStartResponse | MoveEndResponse } WorkerResponse\n *\n * @callback WorkerResponseCallback\n * @param {WorkerResponse} workerResponse - The worker response that is sent via postMessage\n * @returns {void}\n *\n * @typedef {Object} PackParams\n * @prop {BoundsData} [bounds] - The boundaries of the area\n * @prop {PackedCircleData[]} [circles] - The circles\n * @prop {VectorData} [target] - The attraction target\n * @prop {number} [centeringPasses=1] - The number of centering passes\n * @prop {number} [collisionPasses=3] - The number of collistion passes\n * @prop {number} [correctionPasses=3] - The number of overlap correction passes\n * @prop {boolean} [calculateOverlap=false] - Calculate overlap for circles\n * @prop {boolean} [noWorker=false] - Set to true to skip using the Web Worker\n *\n * @typedef {Object} PackResponse\n * @prop {CirclePackerMovementResult} updatedCircles - An object containing all circle data\n * @prop {VectorData} [target] - The attraction target position\n * @prop {CirclePackerOverlappingCircles} [overlappingCircles] - An object containing information about overlapping circles\n */\n\n/**\n * Vector class\n *\n * Most of this code is taken from CirclePackingJS by @onedayitwillmake\n * https://github.com/onedayitwillmake/CirclePackingJS/blob/eb3475b/js-module/web/js/lib/Vector.js\n *\n */\nclass Vector {\n\t/**\n\t * Creates an instance of Vector.\n\t *\n\t * @constructor\n\t * @param {number | VectorData} x - The X component of the Vector\n\t * @param {number} y - The Y component of the Vector\n\t */\n\tconstructor(x, y) {\n\t\tif (typeof x === 'object') {\n\t\t\tthis.x = x.x;\n\t\t\tthis.y = x.y;\n\t\t} else {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a cloned instance of the Vector\n\t *\n\t * @returns {Vector}\n\t */\n\tcp() {\n\t\treturn new Vector(this.x, this.y);\n\t}\n\n\t/**\n\t * Multiplies the vector by a scalar\n\t *\n\t * @param {number} scalar - The scalar to multiply the Vector components with\n\t * @returns {this}\n\t */\n\tmul(scalar) {\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Normalizes the Vector instance\n\t *\n\t * @returns {this}\n\t */\n\tnormalize() {\n\t\tvar l = this.length();\n\t\tthis.x /= l;\n\t\tthis.y /= l;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calculates the length of the Vector instance\n\t *\n\t * @returns {number} - The length of the Vector instance\n\t */\n\tlength() {\n\t\tvar length = Math.sqrt(this.x * this.x + this.y * this.y);\n\n\t\tif (length < 0.005 && length > -0.005) {\n\t\t\treturn 0.000001;\n\t\t}\n\n\t\treturn length;\n\t}\n\n\t/**\n\t * Calculates the distance to another Vector instance\n\t *\n\t * @param {Vector} otherVector - The other Vector instance\n\t * @returns {number} - The distance to the other Vector instance\n\t */\n\tdistance(otherVector) {\n\t\tvar deltaX = this.x - otherVector.x;\n\t\tvar deltaY = this.y - otherVector.y;\n\t\treturn Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\t}\n\n\t/**\n\t * Calculates the distance squared to another Vector instance\n\t *\n\t * @param {Vector} otherVector - The other Vector instance\n\t * @returns {number} - The distance squared to the other Vector instance\n\t */\n\tdistanceSquared(otherVector) {\n\t\tvar deltaX = this.x - otherVector.x;\n\t\tvar deltaY = this.y - otherVector.y;\n\t\treturn deltaX * deltaX + deltaY * deltaY;\n\t}\n}\n\n// most of this code is taken from here:\n// https://github.com/snorpey/CirclePackingJS/blob/master/js-module/web/js/PackedCircle.js\n// by @onedayitwillmake / Mario Gonzalez with some changes by @snorpey\n\n\n/**\n * The Packed circle contains information about a Packed circle\n */\nclass PackedCircle {\n\t/**\n\t * Creates an instance of PackedCircle.\n\t *\n\t * @constructor\n\t * @param {PackedCircleData} - The data to instantiate the PackedCircle with\n\t */\n\tconstructor({ id, radius, x, y, isPulledToTarget, isPinned }) {\n\t\tx = x || 0;\n\t\ty = y || 0;\n\n\t\t/** @type {CircleID} */\n\t\tthis.id = id;\n\n\t\t/**\n\t\t * Where we would like to be\n\t\t *\n\t\t * @type {Vector}\n\t\t **/\n\n\t\tthis.targetPosition = new Vector(0, 0);\n\n\t\t/**\n\t\t * Where we really are\n\t\t *\n\t\t * @type {Vector}\n\t\t **/\n\t\tthis.position = new Vector(x, y);\n\n\t\t/**\n\t\t * Where we we were last time\n\t\t *\n\t\t * @type {Vector}\n\t\t **/\n\t\tthis.previousPosition = new Vector(x, y);\n\n\t\t/**\n\t\t * Is circle being pulled to center?\n\t\t *\n\t\t * @type {boolean}\n\t\t **/\n\t\tthis.isPulledToTarget = isPulledToTarget;\n\n\t\t/**\n\t\t * Is circle pinned inplace\n\t\t *\n\t\t * @type {VectorData}\n\t\t **/\n\t\tthis.isPinned = isPinned;\n\n\t\tthis.setRadius(radius);\n\t}\n\n\t/**\n\t * Update the position of the circle\n\t *\n\t * @param {Vector} aPosition - The new position of the circle\n\t */\n\tsetPosition(aPosition) {\n\t\tthis.previousPosition = this.position;\n\t\tthis.position = aPosition.cp();\n\t}\n\n\t/**\n\t * Updates the radius of the circle\n\t *\n\t * @param {number} aRadius - The new radizs\n\t */\n\tsetRadius(aRadius) {\n\t\tthis.radius = aRadius;\n\t\tthis.radiusSquared = aRadius * aRadius;\n\t}\n\n\t/**\n\t * Returns the distance to the last position of the circle\n\t *\n\t * @type {Vector}\n\t */\n\tget delta() {\n\t\treturn new Vector(\n\t\t\tthis.position.x - this.previousPosition.x,\n\t\t\tthis.position.y - this.previousPosition.y\n\t\t);\n\t}\n}\n\n/**\n * Handle data received by the web worker: Parse JSON\n *\n * @export\n * @param {MessageEvent<string>} event - The worker event\n * @returns {WorkerResponse | undefined}\n */\nfunction processWorkerResponse(event) {\n\treturn event.data ? JSON.parse(event.data) : undefined;\n}\n\n/**\n * Check if circle object is valid\n *\n * @export\n * @param {object | undefined | number | string | boolean | function} circle - The circle to check\n * @returns {boolean}\n */\nfunction isCircleValid(circle) {\n\treturn (\n\t\tcircle &&\n\t\ttypeof circle === 'object' &&\n\t\tcircle !== null &&\n\t\tisIdValid(circle.id) &&\n\t\tcircle.radius &&\n\t\t((circle.position &&\n\t\t\ttypeof circle.position.x === 'number' &&\n\t\t\ttypeof circle.position.y === 'number') ||\n\t\t\t(typeof circle.x === 'number' && typeof circle.y === 'number'))\n\t);\n}\n\n/**\n * Check if bounds object is valid\n *\n * @export\n * @param {object | undefined | number | string | boolean | function} bounds - The bounds object to check\n * @returns {boolean}\n */\nfunction isBoundsValid(bounds) {\n\tif (!typeof bounds === 'object') {\n\t\treturn false;\n\t}\n\n\tif (\n\t\tbounds.point1 &&\n\t\tbounds.point2 &&\n\t\tisPointValid(bounds.point1) &&\n\t\tisPointValid(bounds.point2)\n\t) {\n\t\treturn true;\n\t}\n\n\tif (typeof bounds.width === 'number' && typeof bounds.height === 'number') {\n\t\treturn true;\n\t}\n\n\tif (\n\t\ttypeof bounds.left === 'number' &&\n\t\ttypeof bounds.top === 'number' &&\n\t\ttypeof bounds.bottom === 'number' &&\n\t\ttypeof bounds.right === 'number'\n\t) {\n\t\treturn true;\n\t}\n\n\tif (\n\t\ttypeof bounds.x1 === 'number' &&\n\t\ttypeof bounds.y1 === 'number' &&\n\t\ttypeof bounds.x2 === 'number' &&\n\t\ttypeof bounds.y2 === 'number'\n\t) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Converts bounds data to rect\n *\n * @export\n * @param {object | undefined | number | string | boolean | function} bounds - The BoundsData object\n * @returns {BoundsRect | undefined} - The bounds rect\n */\nfunction boundsDataToRect(bounds) {\n\tif (!isBoundsValid(bounds)) {\n\t\treturn;\n\t}\n\n\tlet left = 0;\n\tlet top = 0;\n\tlet right = 0;\n\tlet bottom = 0;\n\n\tif (typeof bounds.left === 'number') {\n\t\tleft = bounds.left;\n\t\tright = bounds.right;\n\t\ttop = bounds.top;\n\t\tbottom = bounds.bottom;\n\t} else if (typeof bounds.width == 'number') {\n\t\tif (typeof bounds.x === 'number') {\n\t\t\tleft = bounds.x;\n\t\t}\n\n\t\tif (typeof bounds.y === 'number') {\n\t\t\ttop = bounds.y;\n\t\t}\n\n\t\tright = left + bounds.width;\n\t\tbottom = top + bounds.height;\n\t} else if (typeof bounds.x1 === 'number') {\n\t\tleft = bounds.x1;\n\t\tright = bounds.x2;\n\t\ttop = bounds.y1;\n\t\tbottom = bounds.y2;\n\t} else if (bounds.point1) {\n\t\tleft = bounds.point1.x;\n\t\tright = bounds.point2.x;\n\t\ttop = bounds.point1.y;\n\t\tbottom = bounds.point2.y;\n\t}\n\n\treturn { left, top, right, bottom };\n}\n\n/**\n * Check if we can use id\n *\n * @export\n * @param {object | undefined | number | string | boolean | function} id - The id tp check\n * @returns {boolean}\n */\nfunction isIdValid(id) {\n\treturn (typeof id === 'number' && !isNaN(id)) || (typeof id === 'string' && id.length > 0);\n}\n\n/**\n * Check if number is greater than\n *\n * @export\n * @param {object | undefined | number | string | boolean | function} number\n * @param {number} min\n * @returns {boolean}\n */\nfunction isNumberGreaterThan(number, min) {\n\treturn typeof number === 'number' && number >= min;\n}\n\n/**\n * Check if radius is valid\n *\n * @export\n * @param {object | undefined | number | string | boolean | function} point\n * @returns {boolean}\n */\nfunction isPointValid(point) {\n\treturn typeof point === 'object' && typeof point.x === 'number' && typeof point.y === 'number';\n}\n\n// most of this code is taken from here:\n// https://github.com/snorpey/CirclePackingJS/blob/master/js-module/web/js/PackedCircleManager.js\n// by @onedayitwillmake / Mario Gonzalez with some changes by @snorpey\n\n\n/**\n * The PackedCircleManager handles updating the state. It runs in a web worker\n */\nclass PackedCircleManager {\n\t/**\n\t * Creates an instance of PackedCircleManager.\n\t *\n\t * @constructor\n\t */\n\tconstructor() {\n\t\t/** @type {PackedCircle[]} */\n\t\tthis.allCircles = [];\n\n\t\t/** @type {CircleID[]} */\n\t\tthis.pinnedCircleIds = [];\n\n\t\t/** @type {Vector | undefined} */\n\t\tthis.desiredTarget = undefined;\n\n\t\t/** @type {BoundsRect | undefined} */\n\t\tthis.boundsRect = undefined;\n\n\t\t/** @type {number} */\n\t\tthis.damping = 0.025;\n\n\t\t/**\n\t\t * Should all items be pulled to the target?\n\t\t *\n\t\t * @type {boolean}\n\t\t * */\n\t\tthis.isTargetPullActive = true;\n\n\t\t/**\n\t\t * Do we want to calculate overlapping circles for each update?\n\t\t * It might be an expensive operation and is not always needed\n\t\t *\n\t\t * @type {boolean}\n\t\t * */\n\t\tthis.calculateOverlap = false;\n\n\t\t/**\n\t\t * Number of passes for centering\n\t\t * It's (O)logN^2 so use increase at your own risk!\n\t\t * Play with these numbers - see what works best for your project\n\t\t *\n\t\t * @type {number}\n\t\t * */\n\t\tthis.numberOfCenteringPasses = 1;\n\n\t\t/**\n\t\t * Number of passes for collision\n\t\t * It's (O)logN^2 so use increase at your own risk!\n\t\t * Play with these numbers - see what works best for your project\n\t\t *\n\t\t * @type {number}\n\t\t * */\n\t\tthis.numberOfCollisionPasses = 3;\n\n\t\t/**\n\t\t * Number of passes for correcting overlapping circles\n\t\t * This is can be a very expensive operation so increase at your own risk!\n\t\t * Play with these numbers - see what works best for your project\n\t\t *\n\t\t * @type {number}\n\t\t * */\n\t\tthis.numberOfCorrectionPasses = 0;\n\t}\n\n\t/**\n\t * Set the boundary rectangle for the circle packing.\n\t *\n\t * @param {BoundsData} aBoundaryObject - The boundary to set\n\t */\n\tsetBounds(aBoundaryObject) {\n\t\tconst newBoundsRect = boundsDataToRect(aBoundaryObject);\n\n\t\tif (newBoundsRect) {\n\t\t\tthis.boundsRect = newBoundsRect;\n\t\t}\n\t}\n\n\t/**\n\t * Add a circle\n\t *\n\t * @param {CircleData | PackedCircle} aCircle - A Circle to add, should already be created.\n\t */\n\taddCircle(aCircle) {\n\t\tif (!(aCircle instanceof PackedCircle)) {\n\t\t\taCircle = new PackedCircle({\n\t\t\t\tid: aCircle.id,\n\t\t\t\tradius: aCircle.radius,\n\t\t\t\tx: aCircle.position.x || aCircle.x || 0,\n\t\t\t\ty: aCircle.position.y || aCircle.y || 0,\n\t\t\t\tisPinned: aCircle.isPinned || false,\n\t\t\t\tisPulledToTarget:\n\t\t\t\t\ttypeof aCircle.isPulledToTarget === 'boolean' ? aCircle.isPulledToTarget : true,\n\t\t\t});\n\t\t}\n\n\t\tthis.allCircles.push(aCircle);\n\n\t\tif (this.desiredTarget) {\n\t\t\taCircle.targetPosition = this.desiredTarget.cp();\n\t\t}\n\t}\n\n\t/**\n\t * Remove a circle\n\t *\n\t * @param {CircleID} circleToRemoveId - Id of the circle to remove\n\t */\n\tremoveCircle(circleToRemoveId) {\n\t\tthis.allCircles = this.allCircles.filter(circle => circle.id !== circleToRemoveId);\n\t}\n\n\t/**\n\t * Recalculate all circle positions\n\t */\n\tupdatePositions() {\n\t\tconst circleList = this.allCircles;\n\t\tconst circleCount = circleList.length;\n\n\t\t// store information about the previous position\n\t\tfor (let i = 0; i < circleCount; ++i) {\n\t\t\tconst circle = circleList[i];\n\n\t\t\tcircle.previousPosition = circle.position.cp();\n\t\t}\n\n\t\tif (this.desiredTarget && this.isTargetPullActive) {\n\t\t\t// Push all the circles to the target - in my case the center of the bounds\n\t\t\tthis.pushAllCirclesTowardTarget(this.desiredTarget);\n\t\t}\n\n\t\t// Make the circles collide and adjust positions to move away from each other\n\t\tthis.handleCollisions();\n\n\t\t// Collide all circles with bounds (if possible)\n\t\tif (this.boundsRect) {\n\t\t\tthis.handleBoundaryCollisions();\n\n\t\t\t// console.log();\n\n\t\t\t// In case any circles are overlapping after colliding with the bounds,\n\t\t\t// run the collisions a few more times.\n\t\t\tif (this.numberOfCorrectionPasses > 0) {\n\t\t\t\tlet overlapCorrectionTries = 0;\n\t\t\t\tlet overlappingCirclesCount = Object.keys(this.getOverlappingCircles()).length;\n\n\t\t\t\twhile (\n\t\t\t\t\toverlappingCirclesCount > 0 &&\n\t\t\t\t\toverlapCorrectionTries < this.numberOfCorrectionPasses\n\t\t\t\t) {\n\t\t\t\t\tthis.handleCollisions();\n\t\t\t\t\tthis.handleBoundaryCollisions();\n\n\t\t\t\t\toverlappingCirclesCount = Object.keys(this.getOverlappingCircles()).length;\n\t\t\t\t\toverlapCorrectionTries += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Update all circles to move towards a target position\n\t *\n\t * @param {VectorData} aTarget\n\t */\n\tpushAllCirclesTowardTarget(aTarget) {\n\t\tconst circleMovement = new Vector(0, 0);\n\n\t\tconst dragCircle = this.draggedCircle;\n\t\tconst circleList = this.allCircles;\n\t\tconst circleCount = circleList.length;\n\n\t\tfor (\n\t\t\tlet centeringPassNumber = 0;\n\t\t\tcenteringPassNumber < this.numberOfCenteringPasses;\n\t\t\tcenteringPassNumber++\n\t\t) {\n\t\t\tfor (let circleIndex = 0; circleIndex < circleCount; circleIndex++) {\n\t\t\t\tconst circle = circleList[circleIndex];\n\n\t\t\t\tif (circle.isPulledToTarget) {\n\t\t\t\t\t// Kinematic circles can't be pushed around.\n\t\t\t\t\tconst isCircleKinematic =\n\t\t\t\t\t\tcircle === dragCircle || this.isCirclePinned(circle.id);\n\n\t\t\t\t\tif (isCircleKinematic) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tcircleMovement.x = circle.position.x - aTarget.x;\n\t\t\t\t\tcircleMovement.y = circle.position.y - aTarget.y;\n\t\t\t\t\tcircleMovement.mul(this.damping);\n\n\t\t\t\t\tcircle.position.x -= circleMovement.x;\n\t\t\t\t\tcircle.position.y -= circleMovement.y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Packs the circles towards the center of the bounds.\n\t * Each circle will have it's own 'targetPosition' later on\n\t */\n\thandleCollisions() {\n\t\tconst circleCollisionMovement = new Vector(0, 0);\n\n\t\tconst dragCircle = this.draggedCircle;\n\t\tconst circleList = this.allCircles;\n\t\tconst circleCount = circleList.length;\n\n\t\t// Collide circles\n\t\tfor (\n\t\t\tlet collisionPassNumber = 0;\n\t\t\tcollisionPassNumber < this.numberOfCollisionPasses;\n\t\t\tcollisionPassNumber++\n\t\t) {\n\t\t\tfor (let circleAIndex = 0; circleAIndex < circleCount; circleAIndex++) {\n\t\t\t\tconst circleA = circleList[circleAIndex];\n\n\t\t\t\tfor (\n\t\t\t\t\tlet circleBIndex = circleAIndex + 1;\n\t\t\t\t\tcircleBIndex < circleCount;\n\t\t\t\t\tcircleBIndex++\n\t\t\t\t) {\n\t\t\t\t\tconst circleB = circleList[circleBIndex];\n\t\t\t\t\tconst isCircleAPinned = this.isCirclePinned(circleA.id);\n\t\t\t\t\tconst isCircleBPinned = this.isCirclePinned(circleB.id);\n\n\t\t\t\t\t// Kinematic circles can't be pushed around.\n\t\t\t\t\tconst isCircleAKinematic = circleA === dragCircle || isCircleAPinned;\n\t\t\t\t\tconst isCircleBKinematic = circleB === dragCircle || isCircleBPinned;\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t// It's us!\n\t\t\t\t\t\tcircleA === circleB ||\n\t\t\t\t\t\t// Kinematic circles don't interact with eachother\n\t\t\t\t\t\t(isCircleAKinematic && isCircleBKinematic)\n\t\t\t\t\t) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst dx = circleB.position.x - circleA.position.x;\n\t\t\t\t\tconst dy = circleB.position.y - circleA.position.y;\n\n\t\t\t\t\t// The distance between the two circles radii,\n\t\t\t\t\t// but we're also gonna pad it a tiny bit\n\t\t\t\t\tconst combinedRadii = (circleA.radius + circleB.radius) * 1.08;\n\t\t\t\t\tconst distanceSquared = circleA.position.distanceSquared(circleB.position);\n\n\t\t\t\t\tif (distanceSquared < combinedRadii * combinedRadii - 0.02) {\n\t\t\t\t\t\tcircleCollisionMovement.x = dx;\n\t\t\t\t\t\tcircleCollisionMovement.y = dy;\n\t\t\t\t\t\tcircleCollisionMovement.normalize();\n\n\t\t\t\t\t\tconst inverseForce = (combinedRadii - Math.sqrt(distanceSquared)) * 0.5;\n\t\t\t\t\t\tcircleCollisionMovement.mul(inverseForce);\n\n\t\t\t\t\t\tif (!isCircleBKinematic) {\n\t\t\t\t\t\t\tif (isCircleAKinematic) {\n\t\t\t\t\t\t\t\t// Double inverse force to make up\n\t\t\t\t\t\t\t\t// for the fact that the other object is fixed\n\t\t\t\t\t\t\t\tcircleCollisionMovement.mul(2.2);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcircleB.position.x += circleCollisionMovement.x;\n\t\t\t\t\t\t\tcircleB.position.y += circleCollisionMovement.y;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!isCircleAKinematic) {\n\t\t\t\t\t\t\tif (isCircleBKinematic) {\n\t\t\t\t\t\t\t\t// Double inverse force to make up\n\t\t\t\t\t\t\t\t// for the fact that the other object is fixed\n\t\t\t\t\t\t\t\tcircleCollisionMovement.mul(2.2);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcircleA.position.x -= circleCollisionMovement.x;\n\t\t\t\t\t\t\tcircleA.position.y -= circleCollisionMovement.y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Collide circles with boundaries\n\t */\n\thandleBoundaryCollisions() {\n\t\tif (this.boundsRect) {\n\t\t\tthis.allCircles.forEach(circle => {\n\t\t\t\tthis.handleBoundaryForCircle(circle);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Ensure the circle stays inside the boundaries\n\t *\n\t * @param {PackedCircle} aCircle - The circle to check\n\t */\n\thandleBoundaryForCircle(aCircle) {\n\t\tconst { x, y } = aCircle.position;\n\t\tconst radius = aCircle.radius;\n\n\t\tlet isOverEdge = false;\n\n\t\tif (this.boundsRect) {\n\t\t\tif (x + radius >= this.boundsRect.right) {\n\t\t\t\taCircle.position.x = this.boundsRect.right - radius;\n\t\t\t\tisOverEdge = true;\n\t\t\t} else if (x - radius < this.boundsRect.left) {\n\t\t\t\taCircle.position.x = this.boundsRect.left + radius;\n\t\t\t\tisOverEdge = true;\n\t\t\t}\n\n\t\t\tif (y + radius > this.boundsRect.bottom) {\n\t\t\t\taCircle.position.y = this.boundsRect.bottom - radius;\n\t\t\t\tisOverEdge = true;\n\t\t\t} else if (y - radius < this.boundsRect.top) {\n\t\t\t\taCircle.position.y = this.boundsRect.top + radius;\n\t\t\t\tisOverEdge = true;\n\t\t\t}\n\n\t\t\t// end dragging if user dragged over edge\n\t\t\tif (isOverEdge && aCircle === this.draggedCircle) {\n\t\t\t\tthis.draggedCircle = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Calculate overlapping circles for each circle\n\t *\n\t * @returns {CirclePackerOverlappingCircles}\n\t */\n\tgetOverlappingCircles() {\n\t\t/** @type {CirclePackerOverlappingCircles} */\n\t\tconst overlappingCircles = {};\n\n\t\tthis.allCircles.forEach(circleA => {\n\t\t\tconst overlappingCirclesForCircle = this.allCircles\n\t\t\t\t.filter(circleB => circleA.id !== circleB.id)\n\t\t\t\t.map(circleB => {\n\t\t\t\t\tconst distanceBetweenCirclePositions = new Vector(circleA.position).distance(\n\t\t\t\t\t\tcircleB.position\n\t\t\t\t\t);\n\n\t\t\t\t\tconst isOverlapping =\n\t\t\t\t\t\tdistanceBetweenCirclePositions < circleA.radius + circleB.radius;\n\n\t\t\t\t\tconst overlapDistance = isOverlapping\n\t\t\t\t\t\t? circleA.radius + circleB.radius - distanceBetweenCirclePositions\n\t\t\t\t\t\t: 0;\n\n\t\t\t\t\treturn { overlappingCircleId: circleB.id, overlapDistance };\n\t\t\t\t})\n\t\t\t\t.filter(overlapData => {\n\t\t\t\t\treturn overlapData.overlapDistance > 0;\n\t\t\t\t});\n\n\t\t\tif (overlappingCirclesForCircle.length) {\n\t\t\t\toverlappingCircles[circleA.id] = overlappingCirclesForCircle;\n\t\t\t}\n\t\t});\n\n\t\treturn overlappingCircles;\n\t}\n\n\t/**\n\t * Create a positions object that we can send via postmessage\n\t *\n\t * @returns {CirclePackerMovementResult}\n\t */\n\tgetPositions() {\n\t\tconst positions = this.allCircles.reduce((result, circle) => {\n\t\t\tresult[circle.id] = {\n\t\t\t\tid: circle.id,\n\t\t\t\tposition: circle.position,\n\t\t\t\tpreviousPosition: circle.previousPosition,\n\t\t\t\tradius: circle.radius,\n\t\t\t\tdelta: circle.delta,\n\t\t\t\tisPulledToTarget: circle.isPulledToTarget,\n\t\t\t\tisPinned: circle.isPinned,\n\t\t\t};\n\n\t\t\treturn result;\n\t\t}, {});\n\n\t\treturn positions;\n\t}\n\n\t/**\n\t * Force a certain circle to be the 'draggedCircle'.\n\t * Can be used to undrag a circle by calling setDraggedCircle(null)\n\t * @param {PackedCircle | null} aCircle - Circle to start dragging. It's assumed to be part of our list. No checks in place currently.\n\t */\n\tsetDraggedCircle(aCircle) {\n\t\t// Setting to null, and we had a circle before.\n\t\t// Restore the radius of the circle as it was previously\n\t\t// if (this.draggedCircle && this.draggedCircle !== aCircle) {\n\t\t// \tthis.draggedCircle.radius = this.draggedCircle.originalRadius;\n\t\t// }\n\n\t\tthis.draggedCircle = aCircle;\n\t}\n\n\t/**\n\t * Mark circle as dragging\n\t *\n\t * @param {CircleID} id - The ID of the circle we're dragging\n\t */\n\tdragStart(id) {\n\t\tconst draggedCircle = this.allCircles.filter(circle => circle.id === id)[0];\n\t\tthis.setDraggedCircle(draggedCircle);\n\t}\n\n\t/**\n\t * Mark dragged circle as no longer dragging\n\t */\n\tdragEnd() {\n\t\tif (this.draggedCircle) {\n\t\t\t// this.setDraggedCircle(null);\n\t\t\tthis.draggedCircle = null;\n\t\t}\n\t}\n\n\t/**\n\t * Update the position of the circle that is being dragged\n\t *\n\t * @param {CircleID} id - The id of the circle being dragged\n\t * @param {VectorData | Vector} position - The new position of the dragged circle\n\t */\n\tdrag(id, position) {\n\t\tif (this.draggedCircle && position) {\n\t\t\tthis.draggedCircle.position.x = position.x;\n\t\t\tthis.draggedCircle.position.y = position.y;\n\t\t}\n\t}\n\n\t/**\n\t * Check if circle is marked as pinned\n\t *\n\t * @param {CircleID} id - The id of the circle to check\n\t * @returns {boolean}\n\t */\n\tisCirclePinned(id) {\n\t\tconst circle = this.circleById(id);\n\n\t\tif (circle) {\n\t\t\treturn circle.isPinned;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Mark circle as pinned\n\t *\n\t * @param {CircleID} id - The id of the circle we want to pin\n\t */\n\tpinCircle(id) {\n\t\tconst circle = this.circleById(id);\n\n\t\tif (circle) {\n\t\t\tcircle.isPinned = true;\n\t\t}\n\t}\n\n\t/**\n\t * Mark circle as no longer pinned\n\t *\n\t * @param {CircleID} id - The id of the circle we want to unpin\n\t */\n\tunpinCircle(id) {\n\t\tconst circle = this.circleById(id);\n\n\t\tif (circle) {\n\t\t\tcircle.isPinned = false;\n\t\t}\n\t}\n\n\t/**\n\t * set the radius of a circle\n\t *\n\t * @param {CircleID} id - The id of the circle we want to update the radius of\n\t * @param {number} radius - The new radius\n\t */\n\tsetCircleRadius(id, radius) {\n\t\tconst circle = this.circleById(id);\n\n\t\tif (circle) {\n\t\t\tcircle.setRadius(radius);\n\t\t}\n\t}\n\n\t/**\n\t * Update the targetPull value of a circle\n\t *\n\t * @param {CircleID} id - The id of the circle\n\t * @param {boolean} targetPull - The targetPull value\n\t */\n\tsetCircleTargetPull(id, targetPull) {\n\t\tconst circle = this.circleById(id);\n\n\t\tif (circle) {\n\t\t\tcircle.isPulledToTarget = targetPull;\n\t\t}\n\t}\n\n\t/**\n\t * Set a global targetPull value\n\t *\n\t * @param {boolean} targetPull - The global canterPull value\n\t */\n\tsetTargetPull(targetPull) {\n\t\tthis.isTargetPullActive = targetPull;\n\t}\n\n\t/**\n\t * Gets a circle by its id\n\t *\n\t * @param {CircleID} id - The id of the circle we want\n\t * @returns {PackedCircle | undefined}\n\t */\n\tcircleById(id) {\n\t\treturn this.allCircles.filter(circle => circle.id === id)[0];\n\t}\n\n\t/**\n\t * Sets the target position where the circles want to be\n\t *\n\t * @param {VectorData} aPosition - The position of the targetPull target\n\t */\n\tsetTarget(aPosition) {\n\t\tthis.desiredTarget = aPosition;\n\t}\n\n\t/**\n\t * Sets calculate overlap\n\t *\n\t * @param {boolean} calculateOverlap\n\t */\n\tsetCalculateOverlap(calculateOverlap) {\n\t\tthis.calculateOverlap = calculateOverlap;\n\t}\n}\n\n// this code is mostly for message passing between the\n// PackedCircleManager and CirclePacker classes\n\n/**\n * This class handles all logic that can\n * live inside of a web worker. It needs to be a class\n * so that we can instantiate it multiple times for instances of\n * CirclePacker with noWorker = true. We don't want to reuse an\n * WorkerLogic instances for multiple CirclePackers.\n *\n * @export\n * @class WorkerLogic\n * @typedef {WorkerLogic}\n */\nclass WorkerLogic {\n\tconstructor() {\n\t\tthis.circleManager = new PackedCircleManager();\n\t}\n\n\t/**\n\t * Handle message events that were received from the main script\n\t * and trigger the appropriate actions\n\t *\n\t * @param {WorkerMessage} [message]\n\t * @param {WorkerResponseCallback} [handleResponse]\n\t */\n\thandleWorkerMessage(message, handleResponse) {\n\t\tif (message) {\n\t\t\tconst { action } = message;\n\n\t\t\tswitch (action.type) {\n\t\t\t\tcase 'SET_BOUNDS':\n\t\t\t\t\tthis.circleManager.setBounds(action.bounds);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SET_CENTERING_PASSES':\n\t\t\t\t\tthis.circleManager.numberOfCenteringPasses = action.numberOfCenteringPasses;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SET_COLLISION_PASSES':\n\t\t\t\t\tthis.circleManager.numberOfCollisionPasses = action.numberOfCollisionPasses;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SET_CORRECTION_PASSES':\n\t\t\t\t\tthis.circleManager.numberOfCorrectionPasses = action.numberOfCorrectionPasses;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SET_DAMPING':\n\t\t\t\t\tthis.circleManager.damping = action.damping;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SET_TARGET_PULL':\n\t\t\t\t\tthis.circleManager.setTargetPull(action.targetPull);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UPDATE':\n\t\t\t\t\tthis.update();\n\t\t\t\t\tthis.sendPositions(handleResponse);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ADD_CIRCLES':\n\t\t\t\t\tthis.addCircles(action.circles);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'REMOVE_CIRCLE':\n\t\t\t\t\tthis.circleManager.removeCircle(action.id);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'DRAG_START':\n\t\t\t\t\tthis.circleManager.dragStart(action.id);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'DRAG_END':\n\t\t\t\t\tthis.circleManager.dragEnd(action.id);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'DRAG_MOVE':\n\t\t\t\t\tthis.circleManager.drag(action.id, action.position);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SET_CIRCLE_RADIUS':\n\t\t\t\t\tthis.circleManager.setCircleRadius(action.id, action.radius);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SET_CIRCLE_TARGET_PULL':\n\t\t\t\t\tthis.circleManager.setCircleTargetPull(action.id, action.targetPull);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SET_CALCULATE_OVERLAP':\n\t\t\t\t\tthis.circleManager.setCalculateOverlap(action.calculateOverlap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'PIN_CIRCLE':\n\t\t\t\t\tthis.circleManager.pinCircle(action.id);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UNPIN_CIRCLE':\n\t\t\t\t\tthis.circleManager.unpinCircle(action.id);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SET_TARGET':\n\t\t\t\t\tthis.setTarget(action.target);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Create new circles based on the received circle data\n\t *\n\t * @param {PackedCircleData[]} circles - The circles to add\n\t */\n\taddCircles(circles) {\n\t\tif (Array.isArray(circles) && circles.length) {\n\t\t\tcircles.forEach(circle => this.circleManager.addCircle(circle));\n\t\t} else {\n\t\t\tthrow new Error('Circles array is malformed.');\n\t\t}\n\t}\n\n\t/**\n\t * Update the pull targets position\n\t *\n\t * @param {VectorData} target - The new target position\n\t */\n\tsetTarget(target) {\n\t\tif (target && typeof target.x === 'number' && typeof target.y === 'number') {\n\t\t\tthis.circleManager.setTarget(new Vector(target));\n\t\t}\n\t}\n\n\t/**\n\t * Calculate the next circle positions\n\t */\n\tupdate() {\n\t\tthis.circleManager.updatePositions();\n\t}\n\n\t/**\n\t * Send the new circle positions to the main script\n\t *\n\t * @param {WorkerResponseCallback} [handleResponse]\n\t */\n\tsendPositions(handleResponse) {\n\t\tif (handleResponse) {\n\t\t\t/** @type {WorkerResponse} */\n\t\t\tconst responseData = {\n\t\t\t\ttype: 'MOVED',\n\t\t\t\tupdatedCircles: this.circleManager.getPositions(),\n\t\t\t\ttarget: this.circleManager.desiredTarget,\n\t\t\t};\n\n\t\t\tif (this.circleManager.calculateOverlap) {\n\t\t\t\tresponseData['overlappingCircles'] = this.circleManager.getOverlappingCircles();\n\t\t\t}\n\n\t\t\thandleResponse(responseData);\n\t\t}\n\t}\n}\n\n/**\n * This class passes messages to the worker and notifies subscribers\n */\nclass CirclePacker {\n\t/**\n\t * Creates an instance of CirclePacker.\n\t *\n\t * @constructor\n\t * @param {CirclePackerParams} params - The params to instantiate the CirclePacker with\n\t */\n\tconstructor(params = {}) {\n\t\t\n\n\t\t/** @type boolean */\n\t\tthis.useWorker = params.noWorker ? false : true;\n\n\t\t/** @type boolean */\n\t\tthis.destroyAfterOneMove = params.destroyAfterOneMove ? true : false;\n\n\t\t{\n\t\t\tthis.workerLogic = new WorkerLogic();\n\t\t}\n\n\t\t/**\n\t\t * The onMove callback function. Called whenever the circle positions have changed\n\t\t * @type {OnMoveCallback}\n\t\t */\n\t\tthis.onMove = params.onMove || null;\n\n\t\t/**\n\t\t * Stores the circle positions from last update\n\t\t * @type {CirclePackerMovementResult}\n\t\t */\n\t\tthis.lastCirclePositions = {};\n\n\t\tif (params.centeringPasses) {\n\t\t\tthis.setCenteringPasses(params.centeringPasses);\n\t\t}\n\n\t\tif (params.collisionPasses) {\n\t\t\tthis.setCollisionPasses(params.collisionPasses);\n\t\t}\n\n\t\tif (params.correctionPasses) {\n\t\t\tthis.setCorrectionPasses(params.correctionPasses);\n\t\t}\n\n\t\tif (typeof params.calculateOverlap === 'boolean') {\n\t\t\tthis.setCalculateOverlap(params.calculateOverlap);\n\t\t}\n\n\t\tif (params.bounds) {\n\t\t\tthis.setBounds(params.bounds);\n\t\t}\n\n\t\tif (params.target) {\n\t\t\tthis.setTarget(params.target);\n\t\t}\n\n\t\tif (params.circles && params.circles.length) {\n\t\t\tthis.addCircles(params.circles);\n\t\t}\n\n\t\t{\n\t\t\tthis.update();\n\t\t}\n\t}\n\n\t/**\n\t * Handle message that was received from worker\n\t *\n\t * @param {MessageEvent<string>} event\n\t */\n\treceivedWorkerMessage(event) {\n\t\tconst response = processWorkerResponse(event);\n\n\t\tif (response) {\n\t\t\t\n\t\t\tthis.updateListeners(response);\n\t\t}\n\t}\n\n\t/**\n\t * Send message to worker\n\t *\n\t * @param {WorkerAction} action\n\t */\n\tupdateWorker(action) {\n\t\tconst workerMessage = { messageId: Date.now(), action };\n\n\t\t{\n\t\t\t// If no worker is used, we get the result directly via callback\n\t\t\tthis.workerLogic.handleWorkerMessage(workerMessage, response => {\n\t\t\t\t\n\t\t\t\tthis.updateListeners(response);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Update the callbacks\n\t *\n\t * @param {WorkerResponse} response\n\t */\n\tupdateListeners(response) {\n\t\tif (response.type === 'MOVED' && typeof this.onMove === 'function') {\n\t\t\tthis.lastCirclePositions = response.updatedCircles;\n\t\t\tthis.onMove(response.updatedCircles, response.target, response.overlappingCircles);\n\t\t}\n\n\t\t\n\n\t\tif (this.destroyAfterOneMove) {\n\t\t\tthis.destroy();\n\t\t}\n\t}\n\n\t/**\n\t * API for adding circles\n\t *\n\t * @throws Will throw an error if circles parameter is malformed\n\t * @param {PackedCircleData[]} circles - The circles to add\n\t */\n\taddCircles(circles) {\n\t\tif (!Array.isArray(circles)) {\n\t\t\tthrow new Error(`Can't add circles: the circles parameter is not an array.`);\n\t\t}\n\n\t\tif (circles.length) {\n\t\t\tif (!circles.every(isCircleValid)) {\n\t\t\t\tthrow new Error(`Can't add circles: some of the items are not well formatted.`);\n\t\t\t}\n\n\t\t\tthis.updateWorker({ type: 'ADD_CIRCLES', circles });\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * Add a circle\n\t *\n\t * @param {PackedCircleData} circle - The circle to add\n\t */\n\taddCircle(circle) {\n\t\tthis.addCircles([circle]);\n\t}\n\n\t/**\n\t * Removes a circle\n\t *\n\t * @throws Will throw an error if the circle id is malformed\n\t * @param {CircleRef} circleRef - The circle to remove\n\t */\n\tremoveCircle(circleRef) {\n\t\tconst circleId =\n\t\t\ttypeof circleRef === 'object' && circleRef.id !== undefined ? circleRef.id : circleRef;\n\n\t\tif (!isIdValid(circleId)) {\n\t\t\tthrow new Error(`Can't remove circle: the circleRef parameter is malformed.`);\n\t\t} else {\n\t\t\tthis.updateWorker({ type: 'REMOVE_CIRCLE', id: circleId });\n\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * Pins a circle in place\n\t *\n\t * @throws Will throw an error if the circle id is malformed\n\t * @param {CircleRef} circleRef - The circle to pin\n\t */\n\tpinCircle(circleRef) {\n\t\tconst circleId =\n\t\t\ttypeof circleRef === 'object' && circleRef.id !== undefined ? circleRef.id : circleRef;\n\n\t\tif (!isIdValid(circleId)) {\n\t\t\tthrow new Error(`Can't pin circle: the circleRef parameter is malformed.`);\n\t\t} else {\n\t\t\tthis.updateWorker({ type: 'PIN_CIRCLE', id: circleId });\n\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * Unpins a circle\n\t *\n\t * @throws Will throw an error if the circle id is malformed\n\t * @param {CircleRef} circleRef - The circle to unpin\n\t */\n\tunpinCircle(circleRef) {\n\t\tconst circleId =\n\t\t\ttypeof circleRef === 'object' && circleRef.id !== undefined ? circleRef.id : circleRef;\n\n\t\tif (!isIdValid(circleId)) {\n\t\t\tthrow new Error(`Can't unpin circle: the circleRef parameter is malformed.`);\n\t\t} else {\n\t\t\tthis.updateWorker({ type: 'UNPIN_CIRCLE', id: circleId });\n\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * Description placeholder\n\t *\n\t * @throws Will throw an error if the circle id is malformed\n\t * @param {CircleRef} circleRef - The circle to pin\n\t * @param {number} radius - The new radius\n\t */\n\tsetCircleRadius(circleRef, radius) {\n\t\tconst circleId =\n\t\t\ttypeof circleRef === 'object' && circleRef.id !== undefined ? circleRef.id : circleRef;\n\n\t\tif (!isIdValid(circleId)) {\n\t\t\tthrow new Error(`Can't set circle radius: the circleRef parameter is malformed.`);\n\t\t} else if (!isNumberGreaterThan(radius, 0)) {\n\t\t\tthrow new Error(`Can't set circle radius: the passed radius is malformed.`);\n\t\t} else {\n\t\t\tthis.updateWorker({ type: 'SET_CIRCLE_RADIUS', id: circleId, radius });\n\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * Set targetPull value of a Circle\n\t *\n\t * @param {CircleRef} circleRef - The circle\n\t * @param {boolean} targetPull - The new targetPull value\n\t */\n\tsetCircleTargetPull(circleRef, targetPull) {\n\t\tconst circleId =\n\t\t\ttypeof circleRef === 'object' && circleRef.id !== undefined ? circleRef.id : circleRef;\n\n\t\tif (!isIdValid(circleId)) {\n\t\t\tthrow new Error(`Can't set circle center pull: the circleRef parameter is malformed.`);\n\t\t} else {\n\t\t\tthis.updateWorker({\n\t\t\t\ttype: 'SET_CIRCLE_TARGET_PULL',\n\t\t\t\tid: circleId,\n\t\t\t\ttargetPull: !!targetPull,\n\t\t\t});\n\n\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * Set global center pull value\n\t *\n\t * @param {boolean} targetPull - The new targetPull value\n\t */\n\tsetTargetPull(targetPull) {\n\t\tthis.updateWorker({ type: 'SET_TARGET_PULL', targetPull: !!targetPull });\n\t\t\n\t}\n\n\t/**\n\t * Set new boundaries for the area\n\t *\n\t * @throws Will throw an error if the circle id is malformed\n\t * @param {BoundsData} bounds - The new bounddaries\n\t */\n\tsetBounds(bounds) {\n\t\tif (!isBoundsValid(bounds)) {\n\t\t\tthrow new Error(`Can't set bounds: the bounds parameter is malformed.`);\n\t\t} else {\n\t\t\tthis.updateWorker({ type: 'SET_BOUNDS', bounds });\n\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * Set the position of the pull target\n\t *\n\t * @throws Will throw an error if the target position is malformed\n\t * @param {VectorData} targetPos - The position of the pull target\n\t */\n\tsetTarget(targetPos) {\n\t\tif (!isPointValid(targetPos)) {\n\t\t\tthrow new Error(`Can't set target: the targetPos parameter is malformed.`);\n\t\t} else {\n\t\t\tthis.updateWorker({ type: 'SET_TARGET', target: targetPos });\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * Updates the number of centering passes\n\t *\n\t * It's (O)logN^2 so use increase at your own risk.\n\t * Play with these numbers - see what works best for your project.\n\t *\n\t * @throws Will throw an error if the number of centering passes is malformed\n\t * @param {number} numberOfCenteringPasses - The new number of centering passes. Expects a number >= 1\n\t */\n\tsetCenteringPasses(numberOfCenteringPasses) {\n\t\tif (!isNumberGreaterThan(numberOfCenteringPasses, 1)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Can't set centering passes: the numberOfCenteringPasses parameter is malformed.`\n\t\t\t);\n\t\t} else {\n\t\t\tthis.updateWorker({ type: 'SET_CENTERING_PASSES', numberOfCenteringPasses });\n\t\t}\n\t}\n\n\t/**\n\t * Sets the number of collision passes\n\t *\n\t * It's (O)logN^2 so use increase at your own risk.\n\t * Play with these numbers - see what works best for your project.\n\t *\n\t * @throws Will throw an error if the number of collision passes is malformed\n\t * @param {number} numberOfCollisionPasses - Sets the new number of collision passes. Expects a number >= 1\n\t */\n\tsetCollisionPasses(numberOfCollisionPasses) {\n\t\tif (!isNumberGreaterThan(numberOfCollisionPasses, 1)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Can't set collisionPasses passes: the numberOfCollisionPasses parameter is malformed.`\n\t\t\t);\n\t\t} else {\n\t\t\tthis.updateWorker({ type: 'SET_COLLISION_PASSES', numberOfCollisionPasses });\n\t\t}\n\t}\n\n\t/**\n\t * Sets the number of correction passes\n\t *\n\t * This is can be a very expensive operation so increase at your own risk.\n\t * Play with these numbers - see what works best for your project.\n\t *\n\t * @throws Will throw an error if the number of collision passes is malformed\n\t * @param {number} numberOfCorrectionPasses - Sets the new number of correction passes. Expects a number >= 0\n\t */\n\tsetCorrectionPasses(numberOfCorrectionPasses) {\n\t\tif (!isNumberGreaterThan(numberOfCorrectionPasses, 0)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Can't set CorrectionPasses passes: the numberOfCorrectionPasses parameter is malformed.`\n\t\t\t);\n\t\t} else {\n\t\t\tthis.updateWorker({ type: 'SET_CORRECTION_PASSES', numberOfCorrectionPasses });\n\t\t}\n\t}\n\n\t/**\n\t * Should we calculate the overlap on each update?\n\t *\n\t * @throws Will throw an error if calculateOverlap is not boolean\n\t * @param {boolean} calculateOverlap - Sets the calculateOverlap value\n\t */\n\tsetCalculateOverlap(calculateOverlap) {\n\t\tif (typeof calculateOverlap !== 'boolean') {\n\t\t\tthrow new Error(\n\t\t\t\t`Can't set calculateOverlap the calculateOverlap parameter is not a boolean.`\n\t\t\t);\n\t\t} else {\n\t\t\tthis.updateWorker({ type: 'SET_CALCULATE_OVERLAP', calculateOverlap });\n\t\t}\n\t}\n\n\t/**\n\t * Sets the damping value\n\t *\n\t * @throws Will throw an error if damping value is malformed\n\t * @param {number} damping - The new damping value. Expects a number be between 0 and 1\n\t */\n\tsetDamping(damping) {\n\t\tif (!(typeof damping === 'number' && damping > 0 && damping < 1)) {\n\t\t\tthrow new Error(`Can't set damping: the damping parameter is malformed.`);\n\t\t} else {\n\t\t\tthis.updateWorker({ type: 'SET_DAMPING', damping });\n\t\t}\n\t}\n\n\t/**\n\t * Sends a signal to the worker to update the state\n\t */\n\tupdate() {\n\t\tthis.updateWorker({ type: 'UPDATE' });\n\t}\n\n\t/**\n\t * Mark a circle as being dragged\n\t *\n\t * @throws Will throw an error if circle reference is malformed\n\t * @param {CircleRef} circleRef - The circle reference\n\t */\n\tdragStart(circleRef) {\n\t\tconst circleId =\n\t\t\ttypeof circleRef === 'object' && circleRef.id !== undefined ? circleRef.id : circleRef;\n\n\t\tif (!isIdValid(circleId)) {\n\t\t\tthrow new Error(`Can't start dragging circle: the circleRef parameter is malformed.`);\n\t\t} else {\n\t\t\tthis.updateWorker({ type: 'DRAG_START', id: circleId });\n\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * Update the position of a circle that is being dragged\n\t *\n\t * @throws Will throw an error if circle reference or the position is malformed\n\t * @param {CircleRef} circleRef - The circle reference\n\t * @param {VectorData} position - The new position of the circle\n\t */\n\tdrag(circleRef, position) {\n\t\tconst circleId =\n\t\t\ttypeof circleRef === 'object' && circleRef.id !== undefined ? circleRef.id : circleRef;\n\n\t\tif (!isIdValid(circleId)) {\n\t\t\tthrow new Error(`Can't drag circle: the circleRef parameter is malformed.`);\n\t\t} else if (!isPointValid(position)) {\n\t\t\tthrow new Error(`Can't drag circle: the position parameter is malformed.`);\n\t\t} else {\n\t\t\tthis.updateWorker({ type: 'DRAG_MOVE', id: circleId, position });\n\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * Mark a circle as no longer being dragged\n\t *\n\t * @throws Will throw an error if circle reference is malformed\n\t * @param {CircleRef} circleRef - The circle reference\n\t */\n\tdragEnd(circleRef) {\n\t\tconst circleId =\n\t\t\ttypeof circleRef === 'object' && circleRef.id !== undefined ? circleRef.id : circleRef;\n\n\t\tif (!isIdValid(circleId)) {\n\t\t\tthrow new Error(`Can't end dragging circle: the circleRef parameter is malformed.`);\n\t\t} else {\n\t\t\tthis.updateWorker({ type: 'DRAG_END', id: circleId });\n\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * Tear down worker, remove cllbacks\n\t */\n\tdestroy() {\n\t\t\n\n\t\tif (this.worker) {\n\t\t\tthis.worker.terminate();\n\t\t}\n\n\t\tthis.onMove = null;\n\t}\n}\n\n/**\n * Pack circles as simple async function. Only works for one-time operations\n *\n * @export\n * @param {PackParams} params - The params for the circlepacker.\n * @returns {PromiseLike<PackResponse>}\n */\nfunction pack(params = {}) {\n\treturn new Promise((resolve, reject) => {\n\t\t/**\n\t\t * @type {CirclePacker | undefined}\n\t\t */\n\n\t\ttry {\n\t\t\tlet packer;\n\n\t\t\tconst circlePackerParams = {\n\t\t\t\t...params,\n\t\t\t\tanimationLoop: false,\n\t\t\t\tdestroyAfterOneMove: true,\n\t\t\t\tonMove: (updatedCircles, target, overlappingCircles) => {\n\t\t\t\t\tresolve({\n\t\t\t\t\t\tupdatedCircles,\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\toverlappingCircles,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tpacker = new CirclePacker(circlePackerParams);\n\t\t} catch (error) {\n\t\t\treject(error);\n\t\t}\n\t});\n}\n\nCirclePacker.pack = pack;\n\nexport { CirclePacker, pack };\n"],
  "mappings": "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",
  "names": []
}
